% В этом файле следует писать текст работы, разбивая его на
% разделы (section), подразделы (subsection) и, если нужно,
% главы (chapter).

% Предварительно следует указать необходимую информацию
% в файле SETUP.tex

\input{preamble.tex}


\NewBibliographyString{langjapanese}
\NewBibliographyString{fromjapanese}

\begin{document}

\Intro

Гомотопическая теория типов (Homotopy type theory, HoTT) \autocite{hottbook} --- относительно новая область в информатике, которая базируется на неожиданной связи между теорией типов и теорией гомотопий. Эта область лежит в основе Унивалентных оснований математики (Univalent Foundation, UF) \autocite{UFP2010} --- попытки формализовать математику, используя в качестве основы не множества, а гомотопические типы или $\infty$-группоиды, а также высшие индуктивные типы (Higher Inductive Types, HIT). Этот подход в первую очередь интересен тем, что позволяет работать с гомотопической теорией, используя \textit{синтетический метод}, то есть не опираясь на более базовые примитивы, как, например, множества, также очень важным преимуществом HoTT являются хорошие вычислительные свойства, унаследованные от зависимой теории типов Мартин-Лёфа \autocite{MLTT}. Первоначальная версия гомотопической теории типов включала в себя \textit{Аксиому унивалентности}, что открыло возможность для формализации крупного пласта математики на теоретико-типовом языке: экстенсиональности функций и равенства структур, между которыми доказано существование изоморфизма. Но у этой версии было одно очень важное ограничение --- аксиома не имела вычислительной интерпретации. В данный момент наиболее многообещающим решением является использование \textit{кубической теории типов} \autocite{CohenCHM16}, в которой эта аксиома является теоремой, имеющей конструктивное доказательство.

Для обоснования гомотопической интерпретации следует доказать эквивалентность конструкций, которые есть в теории типов с гомотопическими понятиями. В этой работе доказывается изоморфизм между $\Pi$-типом и расслоением.


% Если typeOfWork в SETUP.tex задан как 2 или 3, то начинать
% надо не с section (раздел), а с главы (chapter)
\section{Расслоения}
\label{sec:fiberbundles}

Расслоениями называется класс отображений TODO

\subsection{Определения}

\subsection{Примеры}

\begin{figure}[!h]
\centering
\begin{tikzpicture}[scale=1.50]
\begin{axis}[
    hide axis,
    view={45}{45}
]
%\addplot3 [
%    surf, shader=faceted interp,
%    point meta=x,
%    colormap/jet,
%    samples=40,
%    samples y=5,
%    z buffer=sort,
%    domain=126:135,
%    y domain=-2:22
%] (
%    {sin(x)},
%    {cos(x)},
%    {y-20}); 
\addplot3 [
    surf, shader=faceted interp,
    point meta=x,
    colormap/jet,
    samples=40,
    samples y=5,
    z buffer=sort,
    domain=0:360,
    y domain=-2:2
] (
    {sin(x)},
    {cos(x)},
    {y-20});
\addplot3 [
    samples=50,
    domain=0:360,
    samples y=0,
    thick
] (
    {cos(x)},
    {sin(x)},
    {-20});
\addplot3 [
    samples=50,
    domain=0:360,
    samples y=0,
    thick
] (
    {cos(x)},
    {sin(x)},
    {-10});     
\addplot3 [
    surf, shader=faceted interp,
    point meta=x,
    colormap/jet,
    samples=40,
    samples y=5,
    z buffer=sort,
    domain=0:360,
    y domain=-1:1
] (
    {(1+0.5*y*cos(x/2)))*cos(x)},
    {(1+0.5*y*cos(x/2)))*sin(x)},
    {0.5*y*sin(x/2)});
\addplot3 [
    samples=50,
    domain=-145:180,
    samples y=0,
    thick
] (
    {cos(x)},
    {sin(x)},
    {0}); 
\end{axis}
\end{tikzpicture}
\caption{Примеры расслоений} \label{fig:P1}
\end{figure}

\begin{ListingEnv}[H]
\begin{Verb}
\func neg_neg : \Pi (x : I) -> ((inv seg) @ (inv seg @ x)) = x => \lam x =>
    ((\lam x => (\lam i => inv (squeezePath (inv seg) i)) (inv seg @ x)) x)
    # (inv ((\lam x => ((\lam x => (\lam i => inv (squeezePath seg i)) (seg @ x)) x) # seg) x))

\func twist : I = I => Iso=>Path \new Iso I I neg neg neg_neg neg_neg

\func M : \Pi (x : S1) -> \Type => \lam x => \case x \with {
  | base => I
  | loop i => twist @ i
}

\record Moebius (p1 : S1) {
  \field f1 : M(p1)
}
\end{Verb}
\end{ListingEnv}

\section{$\Pi$-типы}

\subsection{Определение}

\subsection{Примеры}

\section{Построение доказательства}

\Conc

\printbibliography[%{}
    heading=bibintoc%
    ,title=Библиография
]

\appendix
\ifthenelse{\value{worktype} > 1}{%
  \addtocontents{toc}{%
      \protect\renewcommand{\protect\cftchappresnum}{\appendixname\space}%
      \protect\addtolength{\protect\cftchapnumwidth}{\widthof{\appendixname\space{}} - \widthof{Глава }}%
  }%
}{
  \addtocontents{toc}{%
      \protect\renewcommand{\protect\cftsecpresnum}{\appendixname\space}%
      \protect\addtolength{\protect\cftsecnumwidth}{\widthof{\appendixname\space{}}}%
  }%
}

\section{Код доказательства}

\begin{ListingEnv}[H]
\begin{Verb}
\func encode (B : \Type) (F : B -> \Type) (y : B) :
      fiber (total B F) B (trivial B F) y -> F y
   => \lam (x : fiber (total B F) B (trivial B F) y)
   => subst B F x.1.1 y x.2 x.1.2

\func decode (B : \Type) (F : B -> \Type) (y : B) :
      F y -> fiber (total B F) B (trivial B F) y
   => \lam (x : F y) => ((y, x), path (\lam i => y))

\func decode->encode (B : \Type) (F : family B) (y : B) :
  \Pi (x : F y) -> (encode B F y (decode B F y x)) = x
  => \lam (x : F y)
  => path 
  (\lam i 
  => encode B F ((decode B F y x).2 @ i) ((y, x), (path (\lam _ => y))))

\func encode->decode (B : \Type) (F : family B) (y : B) :
  \Pi (x : fiber (total B F) B (trivial B F) y) 
  -> (decode B F y (encode B F y x)) = x
  => \lam (x : fiber (total B F) B (trivial B F) y) 
  => path (\lam i => {?})

\func TrivialFiberBundle=PiType (B : \Type) 
	(F : family B) 
	(y : B) : 
	(fiber (total B F) B (trivial B F) y) = (F y)
  	=> Iso=>Path 
  	(\new Iso 
  	(fiber (total B F) B (trivial B F) y)
  	(F y)
  	(encode B F y) 
  	(decode B F y) 
  	(encode->decode B F y) 
  	(decode->encode B F y))
\end{Verb}
\end{ListingEnv}

\end{document}
